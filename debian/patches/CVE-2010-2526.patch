Description: fix unprivileged logical volume manipulation with clvmd
Origin: vendor, http://patch-tracker.debian.org/patch/series/view/lvm2/2.02.39-8/CVE-2010-2526.patch
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=591204

diff -Nur lvm2-2.02.54/daemons/clvmd/clvmd.c lvm2-2.02.54.new/daemons/clvmd/clvmd.c
--- lvm2-2.02.54/daemons/clvmd/clvmd.c	2009-10-12 04:33:30.000000000 -0400
+++ lvm2-2.02.54.new/daemons/clvmd/clvmd.c	2010-09-23 14:19:16.000000000 -0400
@@ -134,6 +134,7 @@
 static int process_reply(const struct clvm_header *msg, int msglen,
 			 const char *csid);
 static int open_local_sock(void);
+static void close_local_sock(int local_socket);
 static int check_local_clvmd(void);
 static struct local_client *find_client(int clientid);
 static void main_loop(int local_sock, int cmd_timeout);
@@ -275,6 +276,23 @@
 	return buf;
 }
 
+/*
+ * clvmd require dm-ioctl capability for operation
+ */
+static void check_permissions()
+{
+	if (getuid() || geteuid()) {
+		log_error("Cannot run as a non-root user.");
+
+		 /*
+		  * Fail cleanly here if not run as root, instead of failing
+		  * later when attempting a root-only operation
+		  * Preferred exit code from an initscript for this.
+		  */
+		exit(4);
+	}
+}
+
 int main(int argc, char *argv[])
 {
 	int local_sock;
@@ -303,6 +321,7 @@
 			exit(0);
 
 		case 'R':
+			check_permissions();
 			return refresh_clvmd()==1?0:1;
 
 		case 'C':
@@ -348,6 +367,8 @@
 		}
 	}
 
+	check_permissions();
+
 	/* Setting debug options on an existing clvmd */
 	if (debug_opt && !check_local_clvmd()) {
 
@@ -491,6 +512,8 @@
 
 	destroy_lvm();
 
+	close_local_sock(local_sock);
+
 	return 0;
 }
 
@@ -828,7 +851,6 @@
 
       closedown:
 	clops->cluster_closedown();
-	close(local_sock);
 }
 
 static __attribute__ ((noreturn)) void wait_for_child(int c_pipe, int timeout)
@@ -1920,20 +1942,30 @@
 	return ret;
 }
 
+static void close_local_sock(int local_socket)
+{
+	if (local_socket != -1 && close(local_socket))
+		stack;
+
+	if (CLVMD_SOCKNAME[0] != '\0' && unlink(CLVMD_SOCKNAME))
+		stack;
+}
 
 /* Open the local socket, that's the one we talk to libclvm down */
 static int open_local_sock()
 {
-	int local_socket;
+	int local_socket = -1;
 	struct sockaddr_un sockaddr;
+	mode_t old_mask;
+
+	close_local_sock(local_socket);
+	old_mask = umask(0077);
 
 	/* Open local socket */
-	if (CLVMD_SOCKNAME[0] != '\0')
-		unlink(CLVMD_SOCKNAME);
 	local_socket = socket(PF_UNIX, SOCK_STREAM, 0);
 	if (local_socket < 0) {
 		log_error("Can't create local socket: %m");
-		return -1;
+		goto error;
 	}
 	/* Set Close-on-exec & non-blocking */
 	fcntl(local_socket, F_SETFD, 1);
@@ -1944,18 +1976,19 @@
 	sockaddr.sun_family = AF_UNIX;
 	if (bind(local_socket, (struct sockaddr *) &sockaddr, sizeof(sockaddr))) {
 		log_error("can't bind local socket: %m");
-		close(local_socket);
-		return -1;
+		goto error;
 	}
 	if (listen(local_socket, 1) != 0) {
 		log_error("listen local: %m");
-		close(local_socket);
-		return -1;
+		goto error;
 	}
-	if (CLVMD_SOCKNAME[0] != '\0')
-		chmod(CLVMD_SOCKNAME, 0600);
 
+	umask(old_mask);
 	return local_socket;
+error:
+	close_local_sock(local_socket);
+	umask(old_mask);
+	return -1;
 }
 
 void process_message(struct local_client *client, const char *buf, int len,
diff -Nur lvm2-2.02.54/daemons/clvmd/clvm.h lvm2-2.02.54.new/daemons/clvmd/clvm.h
--- lvm2-2.02.54/daemons/clvmd/clvm.h	2009-05-19 06:38:58.000000000 -0400
+++ lvm2-2.02.54.new/daemons/clvmd/clvm.h	2010-09-23 14:19:16.000000000 -0400
@@ -45,9 +45,8 @@
 #define CLVMD_FLAG_SYSTEMLV     2	/* Data in system LV under my node name */
 #define CLVMD_FLAG_NODEERRS     4       /* Reply has errors in node-specific portion */
 
-/* Name of the local socket to communicate between libclvm and clvmd */
-//static const char CLVMD_SOCKNAME[]="/var/run/clvmd";
-static const char CLVMD_SOCKNAME[] = "\0clvmd";
+/* Name of the local socket to communicate between lvm and clvmd */
+static const char CLVMD_SOCKNAME[]= "/var/run/clvmd.sock";
 
 /* Internal commands & replies */
 #define CLVMD_CMD_REPLY    1
